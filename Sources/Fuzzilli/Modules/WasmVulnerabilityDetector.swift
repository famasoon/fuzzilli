// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation

/// Module that scans execution results for WebAssembly specific crash signatures.
///
/// The detector looks for WebAssembly related keywords in the stdout, stderr, and fuzzout
/// streams whenever a program crashes or exits with a non-zero status code. When a
/// suspicious line is found it is normalized into a signature that is tracked for the
/// lifetime of the fuzzer. The first occurrence of a signature is logged at warning level
/// and optionally emitted as a diagnostics artifact so it can be inspected offline.
/// Subsequent occurrences only bump the internal counter which is summarized when the
/// fuzzer shuts down.
public class WasmVulnerabilityDetector: Module {
    struct Finding {
        var count: Int
        var lastOutcome: ExecutionOutcome
        var lastMessage: String
    }

    private unowned let fuzzer: Fuzzer
    private let logger = Logger(withLabel: "WasmVulnerabilityDetector")

    /// Map of normalized signatures to the aggregated finding metadata.
    internal private(set) var findings: [String: Finding] = [:]

    /// Keywords we treat as indicators for WebAssembly related failures.
    private let wasmKeywords: [String] = [
        "webassembly",
        "wasm",
        "wabt",
        "binaryen"
    ]

    public init(for fuzzer: Fuzzer) {
        self.fuzzer = fuzzer
    }

    public func initialize(with fuzzer: Fuzzer) {
        assert(fuzzer === self.fuzzer)

        fuzzer.registerEventListener(for: fuzzer.events.PostExecute) { execution in
            self.process(execution)
        }

        fuzzer.registerEventListener(for: fuzzer.events.Shutdown) { _ in
            self.logSummary()
        }
    }

    private func process(_ execution: Execution) {
        guard execution.outcome.isCrash() || execution.outcome.isFailure() else {
            return
        }

        guard let signature = extractSignature(from: execution) else {
            return
        }

        record(signature: signature, for: execution)
    }

    private func record(signature: String, for execution: Execution) {
        var finding = findings[signature] ?? Finding(count: 0, lastOutcome: execution.outcome, lastMessage: "")
        finding.count += 1
        finding.lastOutcome = execution.outcome
        finding.lastMessage = buildFindingMessage(signature: signature, execution: execution)
        findings[signature] = finding

        if finding.count == 1 {
            logger.warning("Detected potential WebAssembly vulnerability: \(signature)")
            emitDiagnostics(for: signature, message: finding.lastMessage)
        } else {
            logger.verbose("Encountered WebAssembly issue again (\(finding.count)x): \(signature)")
        }
    }

    private func emitDiagnostics(for signature: String, message: String) {
        guard fuzzer.config.enableDiagnostics else { return }
        guard let payload = message.data(using: .utf8) else { return }

        let diagnosticName = "WasmVulnerability-\(sanitizedFileComponent(signature))"
        fuzzer.dispatchEvent(fuzzer.events.DiagnosticsEvent, data: (name: diagnosticName, content: payload))
    }

    private func sanitizedFileComponent(_ signature: String) -> String {
        let sanitized = signature.replacingOccurrences(of: "[^A-Za-z0-9._-]", with: "_", options: .regularExpression)
        if sanitized.isEmpty {
            return "unknown"
        }
        let maxLength = 64
        if sanitized.count <= maxLength {
            return sanitized
        }
        let endIndex = sanitized.index(sanitized.startIndex, offsetBy: maxLength)
        return String(sanitized[..<endIndex])
    }

    private func buildFindingMessage(signature: String, execution: Execution) -> String {
        var message = "Signature: \(signature)\n"
        message += "Outcome: \(execution.outcome)\n"
        message += "\n== STDOUT ==\n"
        message += execution.stdout
        message += "\n== STDERR ==\n"
        message += execution.stderr
        message += "\n== FUZZOUT ==\n"
        message += execution.fuzzout
        return message
    }

    private func extractSignature(from execution: Execution) -> String? {
        let streams = [execution.stdout, execution.stderr, execution.fuzzout]
        for stream in streams {
            for rawLine in stream.split(whereSeparator: \.isNewline) {
                let trimmed = rawLine.trimmingCharacters(in: .whitespacesAndNewlines)
                guard !trimmed.isEmpty else { continue }
                let lowercased = trimmed.lowercased()
                guard wasmKeywords.contains(where: { lowercased.contains($0) }) else { continue }
                return normalize(trimmed)
            }
        }
        return nil
    }

    private func normalize(_ line: String) -> String {
        var normalized = line.trimmingCharacters(in: .whitespacesAndNewlines)
        normalized = normalized.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
        normalized = normalized.replacingOccurrences(of: "0x[0-9a-fA-F]+", with: "0x??", options: .regularExpression)
        return normalized
    }

    private func logSummary() {
        guard !findings.isEmpty else {
            logger.info("No WebAssembly specific crashes observed during the run.")
            return
        }

        logger.info("Summary of WebAssembly related crash signatures: \(findings.count) unique")
        for (signature, finding) in findings.sorted(by: { $0.value.count > $1.value.count }) {
            logger.info("- [\(finding.count)x] \(signature)")
        }
    }
}
