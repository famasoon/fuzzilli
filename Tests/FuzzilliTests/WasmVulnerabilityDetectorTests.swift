// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import XCTest
@testable import Fuzzilli

final class WasmVulnerabilityDetectorTests: XCTestCase {
    func testRecordsSignatureFromStandardError() {
        let config = Configuration(enableDiagnostics: false, isWasmEnabled: true)
        let fuzzer = makeMockFuzzer(config: config)
        let detector = WasmVulnerabilityDetector(for: fuzzer)

        fuzzer.sync {
            detector.initialize(with: fuzzer)

            let execution = MockExecution(outcome: .failed(1),
                                          stdout: "",
                                          stderr: "WebAssembly.RuntimeError: unreachable executed",
                                          fuzzout: "",
                                          execTime: 0.1)
            fuzzer.dispatchEvent(fuzzer.events.PostExecute, data: execution)
        }

        var findings: [String: WasmVulnerabilityDetector.Finding] = [:]
        fuzzer.sync {
            findings = detector.findings
        }

        XCTAssertEqual(findings.count, 1)
        XCTAssertEqual(findings.values.first?.count, 1)
        XCTAssertTrue(findings.keys.first?.contains("WebAssembly.RuntimeError") ?? false)
    }

    func testAggregatesNormalizedSignatures() {
        let config = Configuration(enableDiagnostics: false, isWasmEnabled: true)
        let fuzzer = makeMockFuzzer(config: config)
        let detector = WasmVulnerabilityDetector(for: fuzzer)

        fuzzer.sync {
            detector.initialize(with: fuzzer)

            let first = MockExecution(outcome: .failed(1),
                                      stdout: "",
                                      stderr: "WebAssembly.RuntimeError: illegal instruction at 0xDEADBEEF",
                                      fuzzout: "",
                                      execTime: 0.1)
            fuzzer.dispatchEvent(fuzzer.events.PostExecute, data: first)

            let second = MockExecution(outcome: .failed(1),
                                       stdout: "",
                                       stderr: "WebAssembly.RuntimeError: illegal instruction at 0xCAFEBABE",
                                       fuzzout: "",
                                       execTime: 0.1)
            fuzzer.dispatchEvent(fuzzer.events.PostExecute, data: second)
        }

        var findings: [String: WasmVulnerabilityDetector.Finding] = [:]
        fuzzer.sync {
            findings = detector.findings
        }

        XCTAssertEqual(findings.count, 1)
        XCTAssertEqual(findings.values.first?.count, 2)
    }

    func testEmitsDiagnosticsWhenEnabled() {
        let config = Configuration(enableDiagnostics: true, isWasmEnabled: true)
        let fuzzer = makeMockFuzzer(config: config)
        let detector = WasmVulnerabilityDetector(for: fuzzer)

        var diagnosticsEvents = 0

        fuzzer.sync {
            fuzzer.registerEventListener(for: fuzzer.events.DiagnosticsEvent) { _ in
                diagnosticsEvents += 1
            }

            detector.initialize(with: fuzzer)

            let execution = MockExecution(outcome: .failed(1),
                                          stdout: "",
                                          stderr: "WebAssembly trap: stack overflow",
                                          fuzzout: "",
                                          execTime: 0.1)
            fuzzer.dispatchEvent(fuzzer.events.PostExecute, data: execution)
        }

        XCTAssertEqual(diagnosticsEvents, 1)
    }
}
